{"version":3,"file":"index.min.js","sources":["../src/combineReducers.ts","../src/const.ts","../src/connect.ts","../src/devtools.ts","../src/persist.ts","../src/store.ts","../src/thunk.ts"],"sourcesContent":["import { Action, Reducer } from './store'\n\nexport type Reducers = { [key: string]: Reducer }\n\nexport type ReducerState<R extends Reducer> = R extends Reducer<infer S> ? S : never\n\nexport type State<R extends Reducers> = {\n  [K in keyof R]: ReducerState<R[K]>\n}\n\nexport function combineReducers<R extends Reducers>(reducers: R): Reducer<State<R>> {\n  return (state: State<R> = {} as State<R>, action: Action) => {\n    for (const key in reducers) {\n      state[key] = reducers[key](state[key], action)\n    }\n    return state\n  }\n}","export const dispatchEvent = 'dispatch'\nexport const stateEvent = 'state'","import { Action, Store } from './store'\nimport { stateEvent } from 'const'\n\nexport type DispatchMap = { [key: string]: (event: Event) => void }\n\nexport interface ConnectProps {\n  mapState?(state: any): { [key: string]: any }\n}\n\nexport interface ConnectEvents {\n  mapEvents?(): { [key: string]: (event: Event) => Action }\n}\n\nexport interface Connectable extends HTMLElement, ConnectProps, ConnectEvents {\n  connectedCallback?(): void\n  disconnectedCallback?(): void\n}\n\nexport type Constructor<T> = new (...args: any[]) => T\n\nconst dispatchMap: unique symbol = Symbol()\nconst createDispatchMap: unique symbol = Symbol()\nconst addEventListeners: unique symbol = Symbol()\nconst removeEventListeners: unique symbol = Symbol()\nconst addStateSubscription: unique symbol = Symbol()\nconst removeStateSubscription: unique symbol = Symbol()\nconst onStateChange: unique symbol = Symbol()\n\nexport function connect<T extends Constructor<Connectable>, S>(\n  store: Store<S>,\n  superclass: T\n) {\n  class connected extends superclass {\n    private [dispatchMap]: DispatchMap\n\n    constructor(...args: any[]) {\n      super(...args)\n      this[onStateChange] = this[onStateChange].bind(this)\n      this[createDispatchMap]()\n    }\n\n    connectedCallback() {\n      super.connectedCallback && super.connectedCallback()\n\n      this[addEventListeners]()\n      this[addStateSubscription]()\n    }\n\n    disconnectedCallback() {\n      this[removeStateSubscription]()\n      this[removeEventListeners]()\n\n      super.disconnectedCallback && super.disconnectedCallback()\n    }\n\n    private [createDispatchMap]() {\n      this[dispatchMap] = <DispatchMap>{}\n      if (this.mapEvents) {\n        const eventMap = this.mapEvents()\n        for (const key in eventMap) {\n          const fn = eventMap[key]\n          this[dispatchMap][key] = function (event: Event) {\n            // TODO: add options to mixin to control\n            // event.stopImmediatePropagation()\n            store.dispatch(fn(event))\n          }.bind(this)\n        }\n      }\n    }\n\n    private [addEventListeners]() {\n      for (const key in this[dispatchMap]) {\n        this.addEventListener(key, this[dispatchMap][key], false)\n      }\n    }\n\n    private [removeEventListeners]() {\n      for (const key in this[dispatchMap]) {\n        this.removeEventListener(key, this[dispatchMap][key], false)\n      }\n    }\n\n    private [addStateSubscription]() {\n      store.addEventListener(stateEvent, this[onStateChange])\n      this[onStateChange]()\n    }\n\n    private [removeStateSubscription]() {\n      this.removeEventListener(stateEvent, this[onStateChange])\n    }\n\n    private [onStateChange]() {\n      this.mapState && Object.assign(this, this.mapState(store.state))\n    }\n  }\n\n  return connected as Constructor<Connectable> & T\n}","import { Store, StoreEvent } from \"./store\";\nimport { stateEvent } from \"const\";\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION__: any\n  }\n}\n\nexport function devtools(store: Store<any>) {\n  const extension = window.__REDUX_DEVTOOLS_EXTENSION__\n  \n  if (extension) {\n    const devtools = extension.connect()\n\n    let ignoreState = false\n\n    store.addEventListener(stateEvent, e => {\n      const { action } = (<CustomEvent<StoreEvent>>e).detail\n      if (ignoreState) {\n        ignoreState = false\n      } else {\n        devtools.send(action, store.state)\n      }\n    })\n\n    devtools.subscribe(message => {\n      if (message.type === 'DISPATCH' && message.state) {\n        ignoreState = true\n        store.state = JSON.parse(message.state)\n        // trigger state change for connected components\n        store.dispatch({})\n      }\n    })\n    \n    devtools.init(store.state)\n  }\n  \n  return store\n}","import { Store, StoreEvent, Action } from \"./store\";\nimport { stateEvent } from \"const\";\n\nexport interface Options<S> {\n  // name sets the state key to use, useful in development to avoid conflict\n  // with other apps. Default is to use the app location hostname\n  name: string\n  // filter predicate allows control over whether to persist state based on \n  // the action. Default is to trigger persistence after all actions\n  filter: (action: Action) => boolean\n  // persist allows transforming the state to only persist part of it.\n  // Default is to persist complete state\n  persist: (state: S) => Partial<S>\n  // delay introduces a delay before the save is performed. If another persist\n  // is triggered before it expires, the previous persist is cancelled and a\n  // new one scheduled. This can save doing too many persist operations by\n  // debouncing the triggering. Default is 0 delay\n  delay: number\n  // TODO: version for updates, expiry etc...\n}\n\n// TODO: make storage plugable (localStorage, indexedDB etc...)\n// TODO: plugin storage could be wrapped with lz-string for compression\n//       or provide hooks to transform (before save / after load)\n// TODO: provide methods to purge, clear, flush etc... (state / actions?)\n\nexport function persist<S>(store: Store<S>, options: Partial<Options<S>>) {\n  const opt = {\n    name: location.hostname,\n    filter: (_action: Action) => true,\n    persist: (state: S) => state,\n    delay: 0,\n    ...options\n  }\n\n  const state = localStorage.getItem(opt.name)\n  if (state) {\n    store.state = { ...store.state, ...JSON.parse(state) }\n  }\n\n  let task = 0\n\n  store.addEventListener(stateEvent, e => {\n    const ev = <CustomEvent<StoreEvent>>e\n    const { action } = ev.detail\n\n    if (opt.filter(action)) {\n      if (task) {\n        window.clearTimeout(task)\n      }\n      task = window.setTimeout(() => {\n        localStorage.setItem(opt.name, JSON.stringify(opt.persist(store.state)))\n        task = 0\n      }, opt.delay)\n    }\n  })\n\n  return store\n}\n","import { stateEvent, dispatchEvent } from \"const\"\n\nexport type Action<P = any> = { type?: string, payload?: P }\n\nexport type Dispatch = <A extends Action>(action: A) => any\n\nexport type Reducer<S = any, A = Action> = (state: S, action: A) => S\n\nexport type StoreEvent = { action: Action }\n\nexport class Store<S> extends EventTarget {\n  constructor(public state: S, public reducer: Reducer<S>) {\n    super()\n    this.state = this.reducer(this.state, {})\n  }\n\n  dispatch(action: Action) {\n    const evt = new CustomEvent<StoreEvent>(dispatchEvent, {\n      cancelable: true,\n      detail: { action },\n    })\n\n    if (this.dispatchEvent(evt)) {\n      action = evt.detail.action\n      this.state = this.reducer(this.state, action)\n      this.dispatchEvent(new CustomEvent<StoreEvent>(stateEvent, {\n        detail: { action },\n      }))\n    }\n\n    return action\n  }\n}\n","import { Store, StoreEvent, Dispatch } from \"./store\";\nimport { dispatchEvent } from './const'\n\nexport type ThunkAction = <S>(dispatch: Dispatch, getState: () => S) => void\n\nexport function thunk(store: Store<any>) {\n  const dispatch = store.dispatch.bind(store)\n\n  store.addEventListener(dispatchEvent, e => {\n    const ev = <CustomEvent<StoreEvent>>e\n    const { action } = ev.detail\n\n    if (typeof action === 'function') {\n      const thunk = <ThunkAction>action\n      thunk(dispatch, store.state)\n\n      // stop event going to other listeners (we've handled it)\n      ev.stopImmediatePropagation()\n\n      // stop action being dispatched to reducer (it's a function)\n      ev.preventDefault()\n    }\n  })\n\n  return store\n}\n"],"names":["combineReducers","reducers","state","action","key","dispatchEvent","stateEvent","dispatchMap","Symbol","createDispatchMap","addEventListeners","removeEventListeners","addStateSubscription","removeStateSubscription","onStateChange","connect","store","superclass","[object Object]","args","super","this","bind","connectedCallback","disconnectedCallback","mapEvents","eventMap","fn","event","dispatch","addEventListener","removeEventListener","mapState","Object","assign","devtools","extension","window","__REDUX_DEVTOOLS_EXTENSION__","ignoreState","e","detail","send","subscribe","message","type","JSON","parse","init","persist","options","opt","name","location","hostname","filter","_action","delay","localStorage","getItem","task","ev","clearTimeout","setTimeout","setItem","stringify","Store","EventTarget","reducer","evt","CustomEvent","cancelable","thunk","stopImmediatePropagation","preventDefault"],"mappings":"SAUgBA,EAAoCC,GAClD,MAAO,CAACC,EAAkB,GAAgBC,KACxC,IAAK,MAAMC,KAAOH,EAChBC,EAAME,GAAOH,EAASG,GAAKF,EAAME,GAAMD,GAEzC,OAAOD,GCfJ,MAAMG,EAAgB,WAChBC,EAAa,QCmBpBC,EAA6BC,SAC7BC,EAAmCD,SACnCE,EAAmCF,SACnCG,EAAsCH,SACtCI,EAAsCJ,SACtCK,EAAyCL,SACzCM,EAA+BN,kBAErBO,EACdC,EACAC,GAkEA,OAhEA,cAAwBA,EAGtBC,eAAeC,GACbC,SAASD,GACTE,KAAKP,GAAiBO,KAAKP,GAAeQ,KAAKD,MAC/CA,KAAKZ,KAGPS,oBACEE,MAAMG,mBAAqBH,MAAMG,oBAEjCF,KAAKX,KACLW,KAAKT,KAGPM,uBACEG,KAAKR,KACLQ,KAAKV,KAELS,MAAMI,sBAAwBJ,MAAMI,uBAG9BN,CAACT,KAEP,GADAY,KAAKd,GAA4B,GAC7Bc,KAAKI,UAAW,CAClB,MAAMC,EAAWL,KAAKI,YACtB,IAAK,MAAMrB,KAAOsB,EAAU,CAC1B,MAAMC,EAAKD,EAAStB,GACpBiB,KAAKd,GAAaH,GAAO,SAAUwB,GAGjCZ,EAAMa,SAASF,EAAGC,KAClBN,KAAKD,QAKLH,CAACR,KACP,IAAK,MAAMN,KAAOiB,KAAKd,GACrBc,KAAKS,iBAAiB1B,EAAKiB,KAAKd,GAAaH,IAAM,GAI/Cc,CAACP,KACP,IAAK,MAAMP,KAAOiB,KAAKd,GACrBc,KAAKU,oBAAoB3B,EAAKiB,KAAKd,GAAaH,IAAM,GAIlDc,CAACN,KACPI,EAAMc,iBAAiBxB,EAAYe,KAAKP,IACxCO,KAAKP,KAGCI,CAACL,KACPQ,KAAKU,oBAAoBzB,EAAYe,KAAKP,IAGpCI,CAACJ,KACPO,KAAKW,UAAYC,OAAOC,OAAOb,KAAMA,KAAKW,SAAShB,EAAMd,mBCnF/CiC,EAASnB,GACvB,MAAMoB,EAAYC,OAAOC,6BAEzB,GAAIF,EAAW,CACb,MAAMD,EAAWC,EAAUrB,UAE3B,IAAIwB,GAAc,EAElBvB,EAAMc,iBAAiBxB,EAAYkC,IACjC,MAAMrC,OAAEA,GAAqCqC,EAAGC,OAC5CF,EACFA,GAAc,EAEdJ,EAASO,KAAKvC,EAAQa,EAAMd,SAIhCiC,EAASQ,UAAUC,IACI,aAAjBA,EAAQC,MAAuBD,EAAQ1C,QACzCqC,GAAc,EACdvB,EAAMd,MAAQ4C,KAAKC,MAAMH,EAAQ1C,OAEjCc,EAAMa,SAAS,OAInBM,EAASa,KAAKhC,EAAMd,OAGtB,OAAOc,WCZOiC,EAAWjC,EAAiBkC,GAC1C,MAAMC,EAAM,CACVC,KAAMC,SAASC,SACfC,OAASC,IAAoB,EAC7BP,QAAU/C,GAAaA,EACvBuD,MAAO,KACJP,GAGChD,EAAQwD,aAAaC,QAAQR,EAAIC,MACnClD,IACFc,EAAMd,MAAQ,IAAKc,EAAMd,SAAU4C,KAAKC,MAAM7C,KAGhD,IAAI0D,EAAO,EAiBX,OAfA5C,EAAMc,iBAAiBxB,EAAYkC,IACjC,MAAMqB,EAA8BrB,GAC9BrC,OAAEA,GAAW0D,EAAGpB,OAElBU,EAAII,OAAOpD,KACTyD,GACFvB,OAAOyB,aAAaF,GAEtBA,EAAOvB,OAAO0B,WAAW,KACvBL,aAAaM,QAAQb,EAAIC,KAAMN,KAAKmB,UAAUd,EAAIF,QAAQjC,EAAMd,SAChE0D,EAAO,GACNT,EAAIM,UAIJzC,QC/CIkD,UAAiBC,YAC5BjD,YAAmBhB,EAAiBkE,GAClChD,QADiBC,WAAAnB,EAAiBmB,aAAA+C,EAElC/C,KAAKnB,MAAQmB,KAAK+C,QAAQ/C,KAAKnB,MAAO,IAGxCgB,SAASf,GACP,MAAMkE,EAAM,IAAIC,YAAwBjE,EAAe,CACrDkE,YAAY,EACZ9B,OAAQ,CAAEtC,OAAAA,KAWZ,OARIkB,KAAKhB,cAAcgE,KACrBlE,EAASkE,EAAI5B,OAAOtC,OACpBkB,KAAKnB,MAAQmB,KAAK+C,QAAQ/C,KAAKnB,MAAOC,GACtCkB,KAAKhB,cAAc,IAAIiE,YAAwBhE,EAAY,CACzDmC,OAAQ,CAAEtC,OAAAA,OAIPA,YCzBKqE,EAAMxD,GACpB,MAAMa,EAAWb,EAAMa,SAASP,KAAKN,GAkBrC,OAhBAA,EAAMc,iBAAiBzB,EAAemC,IACpC,MAAMqB,EAA8BrB,GAC9BrC,OAAEA,GAAW0D,EAAGpB,OAEtB,GAAsB,mBAAXtC,EAAuB,CACLA,EACrB0B,EAAUb,EAAMd,OAGtB2D,EAAGY,2BAGHZ,EAAGa,oBAIA1D"}