{"version":3,"file":"index.js","sources":["../src/combineReducers.ts","../src/connect.ts","../src/devtools.ts","../src/persist.ts","../src/store.ts","../src/thunk.ts"],"sourcesContent":["import { Action, Reducer } from './store'\n\nexport type Reducers = { [key: string]: Reducer }\n\nexport type ReducerState<R extends Reducer> = R extends Reducer<infer S> ? S : never\n\nexport type State<R extends Reducers> = {\n  [K in keyof R]: ReducerState<R[K]>\n}\n\nexport function combineReducers<R extends Reducers>(reducers: R): Reducer<State<R>> {\n  return (state: State<R> = {} as State<R>, action: Action) => {\n    for (const key in reducers) {\n      state[key] = reducers[key](state[key], action)\n    }\n    return state\n  }\n}","import { Action, Store } from './store'\n\nexport type DispatchMap = { [key: string]: (event: Event) => void }\n\nexport interface ConnectProps {\n  mapState?(state: any): { [key: string]: any }\n}\n\nexport interface ConnectEvents {\n  mapEvents?(): { [key: string]: (event: Event) => Action }\n}\n\nexport interface Connectable extends HTMLElement, ConnectProps, ConnectEvents {\n  connectedCallback?(): void\n  disconnectedCallback?(): void\n}\n\nexport type Constructor<T> = new (...args: any[]) => T\n\nconst dispatchMap: unique symbol = Symbol()\nconst createDispatchMap: unique symbol = Symbol()\nconst addEventListeners: unique symbol = Symbol()\nconst removeEventListeners: unique symbol = Symbol()\nconst addStateSubscription: unique symbol = Symbol()\nconst removeStateSubscription: unique symbol = Symbol()\nconst onStateChange: unique symbol = Symbol()\n\nexport function connect<T extends Constructor<Connectable>, S>(\n  store: Store<S>,\n  superclass: T\n) {\n  class connected extends superclass {\n    private [dispatchMap]: DispatchMap\n\n    constructor(...args: any[]) {\n      super(...args)\n      this[onStateChange] = this[onStateChange].bind(this)\n      this[createDispatchMap]()\n    }\n\n    connectedCallback() {\n      // this minifies better\n      let callback = super.connectedCallback\n      callback && callback()\n      \n      // super.connectedCallback && super.connectedCallback()\n\n      this[addEventListeners]()\n      this[addStateSubscription]()\n    }\n\n    disconnectedCallback() {\n      this[removeStateSubscription]()\n      this[removeEventListeners]()\n\n      // this minifies better\n      let callback = super.disconnectedCallback\n      callback && callback()\n\n      // super.disconnectedCallback && super.disconnectedCallback()\n    }\n\n    private [createDispatchMap]() {\n      this[dispatchMap] = <DispatchMap>{}\n      if (this.mapEvents) {\n        const eventMap = this.mapEvents()\n        for (const key in eventMap) {\n          const fn = eventMap[key]\n          this[dispatchMap][key] = function (event: Event) {\n            event.stopImmediatePropagation()\n            store.dispatch(fn(event))\n          }.bind(this)\n        }\n      }\n    }\n\n    private [addEventListeners]() {\n      for (const key in this[dispatchMap]) {\n        this.addEventListener(key, this[dispatchMap][key], false)\n      }\n    }\n\n    private [removeEventListeners]() {\n      for (const key in this[dispatchMap]) {\n        this.removeEventListener(key, this[dispatchMap][key], false)\n      }\n    }\n\n    private [addStateSubscription]() {\n      store.addEventListener('state', this[onStateChange])\n      this[onStateChange]()\n    }\n\n    private [removeStateSubscription]() {\n      this.removeEventListener('state', this[onStateChange])\n    }\n\n    private [onStateChange]() {\n      this.mapState && Object.assign(this, this.mapState(store.state))\n    }\n  }\n\n  return connected as Constructor<Connectable> & T\n}","import { Store, StoreEvent } from \"./store\";\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION__: any\n  }\n}\n\nexport function devtools(store: Store<any>) {\n  const extension = window.__REDUX_DEVTOOLS_EXTENSION__\n  \n  if (extension) {\n    const devtools = extension.connect()\n\n    let ignoreState = false\n\n    store.addEventListener('state', e => {\n      const { action } = (<CustomEvent<StoreEvent>>e).detail\n      if (ignoreState) {\n        ignoreState = false\n      } else {\n        devtools.send(action, store.state)\n      }\n    })\n\n    devtools.subscribe(message => {\n      if (message.type === 'DISPATCH' && message.state) {\n        ignoreState = true\n        store.state = JSON.parse(message.state)\n        // trigger state change for connected components\n        store.dispatch({})\n      }\n    })\n    \n    devtools.init(store.state)\n  }\n  \n  return store\n}","import { Store, StoreEvent, Action } from \"./store\";\n\nexport interface Options<S> {\n  // name sets the state key to use, useful in development to avoid conflict\n  // with other apps. Default is to use the app location hostname\n  name: string\n  // filter predicate allows control over whether to persist state based on \n  // the action. Default is to trigger persistence after all actions\n  filter: (action: Action) => boolean\n  // persist allows transforming the state to only persist part of it.\n  // Default is to persist complete state\n  persist: (state: S) => Partial<S>\n  // delay introduces a delay before the save is performed. If another persist\n  // is triggered before it expires, the previous persist is cancelled and a\n  // new one scheduled. This can save doing too many persist operations by\n  // debouncing the triggering. Default is 0 delay\n  delay: number\n  // TODO: version for updates, expiry etc...\n}\n\n// TODO: make storage plugable (localStorage, indexedDB etc...)\n// TODO: plugin storage could be wrapped with lz-string for compression\n//       or provide hooks to transform (before save / after load)\n// TODO: provide methods to purge, clear, flush etc... (state / actions?)\n\nexport function persist<S>(store: Store<S>, options: Partial<Options<S>>) {\n  const opt = {\n    name: location.hostname,\n    filter: (_action: Action) => true,\n    persist: (state: S) => state,\n    delay: 0,\n    ...options\n  }\n\n  const state = localStorage.getItem(opt.name)\n  if (state) {\n    store.state = { ...store.state, ...JSON.parse(state) }\n  }\n\n  let task = 0\n\n  store.addEventListener('state', e => {\n    const ev = <CustomEvent<StoreEvent>>e\n    const { action } = ev.detail\n\n    if (opt.filter(action)) {\n      if (task) {\n        window.clearTimeout(task)\n      }\n      task = window.setTimeout(() => {\n        localStorage.setItem(opt.name, JSON.stringify(opt.persist(store.state)))\n        task = 0\n      }, opt.delay)\n    }\n  })\n\n  return store\n}\n","export type Action<P = any> = { type?: string, payload?: P }\n\nexport type Dispatch = <A extends Action>(action: A) => any\n\nexport type Reducer<S = any, A = Action> = (state: S, action: A) => S\n\nexport type StoreEvent = { action: Action }\n\nexport class Store<S> extends EventTarget {\n  constructor(public state: S, public reducer: Reducer<S>) {\n    super()\n    this.state = this.reducer(this.state, {})\n  }\n\n  dispatch(action: Action) {\n    const evt = new CustomEvent<StoreEvent>('dispatch', {\n      cancelable: true,\n      detail: { action },\n    })\n\n    if (this.dispatchEvent(evt)) {\n      action = evt.detail.action\n      this.state = this.reducer(this.state, action)\n      this.dispatchEvent(new CustomEvent<StoreEvent>('state', {\n        detail: { action },\n      }))\n    }\n\n    return action\n  }\n}\n","import { Store, StoreEvent, Dispatch } from \"./store\";\n\nexport type ThunkAction = <S>(dispatch: Dispatch, getState: () => S) => void\n\nexport function thunk(store: Store<any>) {\n  const dispatch = store.dispatch.bind(store)\n\n  store.addEventListener('dispatch', e => {\n    const ev = <CustomEvent<StoreEvent>>e\n    const { action } = ev.detail\n\n    if (typeof action === 'function') {\n      const thunk = <ThunkAction>action\n      thunk(dispatch, store.state)\n\n      // stop event going to other listeners (we've handled it)\n      ev.stopImmediatePropagation()\n\n      // stop action being dispatched to reducer (it's a function)\n      ev.preventDefault()\n    }\n  })\n\n  return store\n}\n"],"names":["combineReducers","reducers","state","action","key","dispatchMap","Symbol","createDispatchMap","addEventListeners","removeEventListeners","addStateSubscription","removeStateSubscription","onStateChange","connect","store","superclass","[object Object]","args","super","this","bind","callback","connectedCallback","disconnectedCallback","mapEvents","eventMap","fn","event","stopImmediatePropagation","dispatch","addEventListener","removeEventListener","mapState","Object","assign","devtools","extension","window","__REDUX_DEVTOOLS_EXTENSION__","ignoreState","e","detail","send","subscribe","message","type","JSON","parse","init","persist","options","opt","name","location","hostname","filter","_action","delay","localStorage","getItem","task","ev","clearTimeout","setTimeout","setItem","stringify","Store","EventTarget","reducer","evt","CustomEvent","cancelable","dispatchEvent","thunk","preventDefault"],"mappings":"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"}